package agent

//Receptor - минимальная единица, передающая вещества от входных данных
/*
Является, по сути переводчиком с языка цифр (информации) на язык веществ

Данные складываются в специальный файл и сразу обрабатываются. Вычисляются их производные по времени и пространству, и вторые производные
и даже скорость.
На каждый из этих параметров (чистых и вычисленных) необходимо поставить по два рецептора - положительный и отрицательный.
Положительный выдает вещество (ацетилхолин?) по своим аксонам пропорцианально величине параметра.
Отрицательный выдает вещество обратно пропорцианально величине параметра.
Например, если данные состоят из байтов:
при значении 200 в данных, рецептор положительный выдаст 200 ацетилхолина, а отрицательный выдаст 255-200=55
при значении 0 в данных, рецептор положительный выдаст 0 ацетилхолина, а отрицательный выдаст 255-0=255

Еще можно разработать рецептор среднего значения, который тем больше плюет, чем ближе к среднему значению.
Да и вообще какой угодно, если угодно, надо экспериментировать))
Таким образом, вещества сигнализируют не только большие данные, а вообще всякие.

У рецепторов аксоны направлены в свой файл синапсов, свойственный данному типу входного сигнала.
Фактически, первичная зрительная кора, например, будет распологаться (и клеточно и синаптически) отдельно от мозга, являясь периферическим входом
*/
type Receptor struct {
	typer byte //Тип рецептора  - четные значения для положительных рецепторов, нечетные - для отрицательных
	core  byte /*номер ядра, в синапсах которого находятся аксоны
	0xff - аксоны в этом синптическом поле, а не в ядре мозга. Значит есть еще нейроны, кроме рецепторов, и уже нейроны передадут
	в мозг инфу
	0xfe - аксоны расположены в общем синаптическом файле всех входов мозга (для реализации связей между разными входами)
	*/

	Ndata  uint32 //номер ячейки с данными, на которую нацелен рецептор
	NdataW byte   //номер бита/байта/слова... из этой ячейки

	typemedi byte //тип выплевываемого медиатора (обычно ацетилхолин)

	force    uint16 //сила реакции
	divforce uint16 /*обратная сила реакции
	для разных типов означает что-то свое, но чаще всего это коэффициенты количества вещества в ответ на стимул:
	vesiculs = val * force / divforce
	Для рецепторов обратного типа (0xff-val)*f/df
	*/

	threshold uint64 /*порог срабатывания.
	0 (или 0xff для отрицательного рецептора) означает, что нет порога
	обычно - это величина, ниже (или выше, если рецептор отрицательного типа) которой рецептор молчит
	*/

	//У каждого рецептора до 32 аксонов, которые передают вещества
	A     uint32   //Состояния аксонов. каждый бит отвечает за 1 аксон. Если он 1 - аксон есть и его надо обрабатывать
	axons [32]Axon //Координаты аксонов в общем файле синапсов, количество везикул и кальций
	//
}

//DoReceptorUInt32 - запустить обработку ячейки данных. Возвращает количество выброшенного вещества.
func (r *Receptor) DoReceptorUInt32(d *DataUInt32) byte {
	var (
		val uint32  //значение, которое анализируем
		f   float32 //применение функции анализа
		res byte    //количества вещества, которое хотим выплюнуть
	)
	//вычисляем величину медиатора
	if r.typer%2 == 0 { //четный - положительный
		val = d.data[r.NdataW]
	} else {
		val = 0xffffffff - d.data[r.NdataW]
	}
	if r.threshold > uint64(val) {
		return 0
	}
	f = float32(val) * float32(r.force) / float32(r.divforce)
	if f > 255 {
		f = 255
	} else if f < 1 {
		return 0
	}

	//проходимся по всем аксонам и плюем эту величину
	res = 10
	return res //заглушка TODO
}
