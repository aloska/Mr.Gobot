package agent

/*GenNeuron - структура одного гена нейронов из файла генома

 */
type GenNeuron struct {
	typen NeuronTypeEnum //тип клетки: 10 - стволовые...
	serv1 byte           //зарезервировано (byte выравнивание)
	core  CoreEnum       /*номер синаптического поля (ядра или входа или выхода), в синапсах которого находятся аксоны
	0xffff - аксоны в этом же поле синапсов, текущем, где описан нейрон
	x - аксоны в ядре х, это сигнал ядру, что оно должно АКСОНЫ нейрона обрабатывать в другом файле синапсов
	если x совпадет с номером этого ядра - будет тоже самое, что 0xffff
	у ядра есть ссылка на весь организм, и оно может попросить у организма нужный синапс из любого поля синапсов

	0xfffe - аксоны расположены в общем синаптическом файле всех входов мозга (для реализации связей между разными входами)
	Поскольку нейроны могут быть расположены не только в мозге, но и в входных устройствах, у всех входных устройств может быть свое
	синаптическое поле, и обязательно есть общее синаптическое поле (в простых агентах это может не использоваться, но возможность такая есть)

	Итого у нас 0xffff зарезервирован для текущего ядра (или текущего входа),
		а 0xfffe зарезервирован для общего поля всех входов
	*/

	maxX uint32 /*(количество синапсов по Х) максимальная ширина файла синапсов того поля синапсов, где лежит сома, т.е. этого текущего ядра
	  Эта величина используется для вычисления номера синапса в одномерном массиве синапсов, исходя из
	  координат:  N = x + y * maxX
	  При генерации клеток, вычисляют сначала их координаты (и координаты отростков), а потом переводятся
	  в индекс одномерного массива
	  Массив одномерный, потому что Го плохо работает с многомерными, а там надо отображения с файла иметь
	*/

	maxXOtherCore uint32 //если аксоны находятся в другом файле синапсов, отличных от текущего, т.е. core!=COREMY, то нужно знать ширину того поля

	layers   uint16 //количество слоев таких клеток
	laywidth uint32 //количество клеток в одном слое (умножить на layers и будет клеток всего)

	soma1stX        uint32 //x-координата сомы 1ой клетки в 1ом слое
	soma1stY        uint32 //y-координата сомы 1ой клетки в 1ом слое
	somaNextShiftX  uint16 //сдвиг каждой следующей сомы по координате X
	somaNextShiftY  uint16 //сдвиг каждой следующей сомы по координате Y
	somaLayerShiftX uint16 //сдвиг каждого слоя относительно предыдущего по Х
	somaLayerShiftY uint16 //сдвиг каждого слоя относительно предыдущего по Y

	dend1stX        uint32 //x-координата 1-го дендрита 1ой клетки в 1ом слое
	dend1stY        uint32 //y-координата 1-го дендрита 1ой клетки в 1ом слое
	dendShiftX      uint16 //сдвиг каждого следующего дендрита одной и той же клетки по координате X
	dendShiftY      uint16 //сдвиг каждого следующего дендрита одной и той же клетки по координате Y (тогда дендриты одной клетки будут по диагонали распологаться)
	dendNextShiftX  uint16 //сдвиг 1-го дендрита следующей клетки по координате X относительно 1-го дендрита предыдущей клетки
	dendNextShiftY  uint16 //сдвиг 1-го дендрита следующей клетки по координате Y относительно 1-го дендрита предыдущей клетки
	dendLayerShiftX uint16 //сдвиг следующего слоя по Х
	dendLayerShiftY uint16 //сдвиг следующего слоя по Y
	/*про дендриты кажется запутанным, но:
	         Y=201
	           | 	   одними символами обозначены дендриты одной клетки
	          \|/       на рисунке ось Х направлена вправо, ось У вниз
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	X=354--->| x |   |   |   | + |   |   |   | 0 |   |   |   | # |   |   |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         |   | x |   |   |   | + |   |   |   | 0 |   |   |   | # |   |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         |   |   | x |   |   |   | + |   |   |   | 0 |   |   |   | # |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         | " |   |   | x | @ |   |   | + | $ |   |   | 0 | % |   |   | # |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         |   | " |   |   | x | @ |   |   | + | $ |   |   | 0 | % |   |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         |   |   | " |   |   | x | @ |   |   | + | $ |   |   | 0 | % |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
			 |   |   |   | " |   |   | x | @ |   |   | + | $ |   |   | 0 | % |
			 +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

	dend1stX        =  354
	dend1stY        =  201
	dendShiftX      =  1
	dendShiftY 	    =  1
	dendNextShiftX  =  4
	dendNextShiftY  =  0
	dendLayerShiftX =  0
	dendLayerShiftY =  3
	*/

	ax1stX        uint32 //x-координата 1-го аксона 1ой клетки в 1ом слое
	ax1stY        uint32 //y-координата 1-го аксона 1ой клетки в 1ом слое
	axShiftX      uint16 //сдвиг каждого следующего аксона одной и той же клетки по координате X
	axShiftY      uint16 //сдвиг каждого следующего аксона одной и той же клетки по координате Y (тогда аксоны одной клетки будут по диагонали распологаться)
	axNextShiftX  uint16 //сдвиг 1-го аксона следующей клетки по координате X относительно 1-го аксона предыдущей клетки
	axNextShiftY  uint16 //сдвиг 1-го аксона следующей клетки по координате Y относительно 1-го аксона предыдущей клетки
	axLayerShiftX uint16 //сдвиг следующего слоя по Х
	axLayerShiftY uint16 //сдвиг следующего слоя по Y

	neuron Neuron //типичный нейрон для такого типа клеток (используется для генерации клеток)

}

/*GenData - структура гена для файлов с данными
При первом старте агента, ВМ считывает ген из файла и создает файл входных данных по генетическому описанию.
Ген также содержит некоторые описания работы с этими данными, специфичными для разных типов данных. Поэтому он нужен не только при
генерации файла с данными, но и при работе с ними
*/
type GenData struct {
	datatype uint16 //тип данных из data.go  1-DataByte...
	dataneed byte   /*нуждаются ли данные в дополнительной мат-оброботке. 0 - они полностью готовы к использованию
	(тот, кто ложил или присылал данные позаботился о предварительных вычислениях)*/

	runifchange byte //надо ли запускать рецепторы сразу при приходе новых данных, или пользоваться только частотной характеристикой

	fps      uint16 //средняя частота обновления данных, милисек. 0-данные нужно обрабатывать как можно чаще
	httpchan uint16 /*Канал http-данных. уникальное число для этого входа
	0 - без канала (означает, что данные записывает прямо в файл некий сторонний процесс)
	1,2,3... данные получает агент на свой http-сервер через апи
	в настоящий момет используется только возможность http, т.к.
	для  непоследственной записи сторонним процессом необходимо разбираться более глубоко в MemoryMap
	*/
	len uint32 //длина данных (количество ячеек с данными, а не размер файла!!)

}

/*GenReceptor - ген рецепторов
Этот ген может сгенерировать рецепторы любого типа. Просто некоторые названия полей будут для разных типов рецепторов иметь
разный смысл.
*/
type GenReceptor struct {
	typer uint16 //тип рецептора. четные - для положительных, нечетные - для отрицательных

	core    CoreEnum //в какое синаптическое поле направлены аксоны этих клеток, 0xffff - в это же, в поле входа
	maxData uint32   //максимальное количество ячеек с данными, которые рецептируют данные рецепторы

	layers   uint16 //количество слоев таких рецепторов
	laywidth uint32 //количество рецепторов в одном слое (умножить на layers и будет рецепторов всего)

	Ndata  uint32 //номер ячейки с данными, которую рецептирует 1ый рецептор в 1ом слое
	NdataW byte   //номер бита/байта/слова... из этой ячейки

	typemedi byte //тип выплевываемого медиатора (обычно ацетилхолин)

	NdataShift  uint16 //сдвиг каждого следующего рецептора по номеру ячейки данных (обычно 1: рецепторы нацелены на подряд идущие ячейки с данными)
	NdataWShift byte   //сдвиг каждого слоя по номеру бита/байта/слова

	serv2 byte //зарезервировано (выравнивает byte)

	maxX uint32 //ширина синаптического поля, куда направлены аксоны рецептора

	ax1stX        uint32 //x-координата 1-го аксона 1ой рецептора в 1ом слое
	ax1stY        uint32 //y-координата 1-го аксона 1ой рецептора в 1ом слое
	axShiftX      uint16 //сдвиг каждого следующего аксона одной и той же рецептора по координате X
	axShiftY      uint16 //сдвиг каждого следующего аксона одной и той же рецептора по координате Y (тогда аксоны одной рецептора будут по диагонали распологаться)
	axNextShiftX  uint16 //сдвиг 1-го аксона следующей рецептора по координате X относительно 1-го аксона предыдущей рецептора
	axNextShiftY  uint16 //сдвиг 1-го аксона следующей рецептора по координате Y относительно 1-го аксона предыдущей рецептора
	axLayerShiftX uint16 //сдвиг следующего слоя по Х
	axLayerShiftY uint16 //сдвиг следующего слоя по Y

	receptor Receptor //типичный рецептор для такого типа рецепторов (используется для генерации)

}

/*
Механизм работы выходов
-----------------------

Выходы состоят из преффекторов (Preffector) и эффекторов (Effector)
Преффекторы - это что-то похожее на нейроны, только они не приспосабливаются, не имеют веществ внутри себя, имеют большое дендритное дерево,
"слушающее" в принципе любое указанное синаптическое поле. У преффекторов есть только один выход - некая величина байта, которую они хранят
внутри себя. Преффекторы могут быть разных типов (например, положительные и отрицательные). Положительные увеличивают свой выход (байт)  в ответ
на присутствие неких веществ, а отрицательные увелчивают свой выход в ответ на отсутствие.
Дендриты преффекторов все метаботробные.
У каждого преффектора есть число-указатель (по сути номер) эффектора.
Эффектор считывает со своих преффекторов выходы и принимает решение о неком среднем (или целом значении), которое и записывается в выходной файл.
Файл выходной является по сути выходом из организма. Его данные попадают на исполнительные устройства через драйвера, или организм может
анализировать содержимое некоторых из них в своих целях.

*/

/*GenPreffector - рецепторы "наоборот", переводят вещества в данные, которые потом анализируют эффекторы и выводят в выходной файл

 */
type GenPreffector struct {
	typep uint16   //тип преффектора
	core  CoreEnum //синаптическое поле, где лежат дендриты преффектора (может быть свое поле)

	layers   uint16 //количество слоев таких преффекторов
	laywidth uint32 //количество преффекторов в одном слое (умножить на layers и будет преффекторов всего)

	Ndata  uint32 //номер ячейки в выходном файле, на который действует 1ый преффектор в 1ом слое
	NdataW byte   //номер бита/байта/слова...

	serv1 byte //

	NdataShift  uint16 //сдвиг каждого следующего преффектора по номеру ячейки выходных данных (обычно 1: преффекторы нацелены на подряд идущие ячейки с выходными данными)
	NdataWShift byte   //сдвиг каждого слоя по номеру бита/байта/слова
	/*Если в файле только одно число uint32, и тип преффектора - битовый, то ген настроим так, например:
	Мы хотим, чтобы старшие биты инервировались бОльшим числом преффекторов, чем младшие (поскольку старшие биты числа важнее младших)
	Значит, нам нужен файл из некоторого количества uint32, среднее из которых будет выходным числом. Это среднее нужно будет
	посчитать драйверу выходного устройства
		typee = EFFECTORINT32
		fsize = 4  //4 байта размер файла
		layers = 1	//слой
	*/

	serv2 byte //зарезервировано (выравнивает byte)

	maxX uint32 //ширина файла синапсов, где лежат дендриты

	dend1stX        uint32 //x-координата 1-го дендрита 1ой клетки в 1ом слое
	dend1stY        uint32 //y-координата 1-го дендрита 1ой клетки в 1ом слое
	dendShiftX      uint16 //сдвиг каждого следующего дендрита одной и той же клетки по координате X
	dendShiftY      uint16 //сдвиг каждого следующего дендрита одной и той же клетки по координате Y (тогда дендриты одной клетки будут по диагонали распологаться)
	dendNextShiftX  uint16 //сдвиг 1-го дендрита следующей клетки по координате X относительно 1-го дендрита предыдущей клетки
	dendNextShiftY  uint16 //сдвиг 1-го дендрита следующей клетки по координате Y относительно 1-го дендрита предыдущей клетки
	dendLayerShiftX uint16 //сдвиг следующего слоя по Х
	dendLayerShiftY uint16 //сдвиг следующего слоя по Y

	prefector Preffector //пример такого эффектора
}

/*GenDataOut - ген файла выходных данных
 */
type GenDataOut struct {
	datatype uint16 //тип выходных данных из data.go

	fps      uint16 //средняя частота обновления данных, милисек. 0-данные нужно складывать как можно чаще
	httpchan uint16 /*Канал http-данных. уникальное число для этого выхода
	0 - без канала (означает, что данные забирает прямо из файла некий сторонний процесс)
	1,2,3... данные отсылает агент на http-сервер через апи
	*/
	len uint32 //длина данных (количество ячеек с данными, а не размер файла!!)

}
