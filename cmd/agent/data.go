package agent

/*
ЯЧЕЙКИ С ДАННЫМИ
----------------
Каждый вход должен быть описан в отдельнном файле генома. В той же папке должен находится хотя бы один файл с описанием рецепторов к этим данным.
В папке может также находится геном с описанием нейронов, и тогда система создаст свое синапстическое поле для этого входа.
Система, обработав геномы, создаст файл со структорой данных и файл(ы) со структурой рецепторов. Если есть описание геномов для нейронов -
то еще и файлы нейронов (наподобие ядер) и файл общего синаптического поля для этого входа.
Файл данных может содержать только один тип данных, и файл генома данных тоже содержит только один ген.
Файл(ы) рецепторных клеток могут содержать разные рецепторы и слои. Файл(ы) генома рецепторов тоже могут содержать, как следствие, описания
разных рецепторов (без нейронов!).
Нейроны в отдельных файлах описывать!

*/

/*DataByte - ячейка с побайтовыми данными во входном файле
алггоритм заполнения этой ячейки, при получении входных данных:
1. dSt 		-> dSt2
2. dSx 		-> dSx2
3. dSt 		<- N - N[old] (разница между текущим значением и старым)
4. dSx 		<- N - N+1    (разница между текущим байтом и следующим за ним, если он есть)
5. N  		<- слово    (положить текущее слово данных на свое место)
6. d2St		<- dSt-dSt2  разница между текущей разницей и предыдущей (2-ая производная)
7. d2Sx		<- dSx-dSx2
8. dSxdSt 	<- dSx/dSt

data[0]:	data   byte // слово с данными
data[1]:	dSt    byte // текущая разница по времени
data[2]:	dSt2   byte //3:dSt2 предыдущая разница по времени
data[3]:	d2St   byte //4:d2St вторая производная по времени
data[4]:	dSx    byte //5:dSx   текущая разница по пространству
data[5]:	dSx2   byte //6:dSx2  предыдущая разница по пространству
data[6]:	d2Sx   byte //7:d2Sx  вторая производная по пространству
data[7]:	dSxdSt byte //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
*/
type DataByte struct {
	data [8]byte
}

/*DataInt16 - ячейка с поинтовым16
 */
type DataInt16 struct {
	data [8]int16
}

/*DataInt32 - ячейка с поинтовым32
 */
type DataInt32 struct {
	data [8]int32
}

/*DataInt64 - ячейка с поинтовым64
 */
type DataInt64 struct {
	data [8]int64
}

/*DataUInt16 - ячейка с поинтовым16
 */
type DataUInt16 struct {
	data [8]uint16
}

/*DataUInt32 - ячейка с поинтовым32
 */
type DataUInt32 struct {
	data [8]uint32
}

/*DataUInt64 - ячейка с поинтовым64
 */
type DataUInt64 struct {
	data [8]uint64
}

/*DataFloat32 - ячейка с плавающим
 */
type DataFloat32 struct {
	data [8]float32
}

/*DataFloat64 - ячейка с плавающим
 */
type DataFloat64 struct {
	data [8]float64
}

/*DataBit - ячейка с данными из битов (если существенны именно биты)
Данные, кстати можно варьировать и комбинировать для одних и тех же входящих данных. Все это должно быть просто описано в рецепторном геноме

*/
type DataBit struct {
	data byte //данные
	mask byte //маска битов
}

/*DataRune - на самом деле, rune - это int32. Просто при обработке слов не нужны все эти производные - они не имеют смысла
Поэтому, текстовые данные обрабатываем этой простой структурой из 4 байт
*/
type DataRune struct {
	data rune // слово с данными

}
