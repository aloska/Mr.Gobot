package agent

/*
ЯЧЕЙКИ С ДАННЫМИ
----------------
Каждый вход должен быть описан в отдельнном файле генома. В той же папке должен находится хотя бы один файл с описанием рецепторов к этим данным.
В папке может также находится геном с описанием нейронов, и тогда система создаст свое синапстическое поле для этого входа.
Система, обработав геномы, создаст файл со структорой данных и файл(ы) со структурой рецепторов. Если есть описание геномов для нейронов -
то еще и файлы нейронов (наподобие ядер) и файл общего синаптического поля для этого входа.
Файл данных может содержать только один тип данных, и файл генома данных тоже содержит только один ген.
Файл(ы) рецепторных клеток могут содержать разные рецепторы и слои. Файл(ы) генома рецепторов тоже могут содержать, как следствие, описания
разных рецепторов (без нейронов!).
Нейроны в отдельных файлах описывать!

*/

/*DataByte - ячейка с побайтовыми данными во входном файле
алггоритм заполнения этой ячейки, при получении входных данных:
1. dSt 		-> dSt2
2. dSx 		-> dSx2
3. dSt 		<- N - N[old] (разница между текущим значением и старым)
4. dSx 		<- N - N+1    (разница между текущим байтом и следующим за ним, если он есть)
5. N  		<- слово    (положить текущее слово данных на свое место)
6. d2St		<- dSt-dSt2  разница между текущей разницей и предыдущей (2-ая производная)
7. d2Sx		<- dSx-dSx2
8. dSxdSt 	<- dSx/dSt
*/
type DataByte struct {
	data   byte // слово с данными
	dSt    byte // текущая разница по времени
	dSt2   byte //3:dSt2 предыдущая разница по времени
	d2St   byte //4:d2St вторая производная по времени
	dSx    byte //5:dSx   текущая разница по пространству
	dSx2   byte //6:dSx2  предыдущая разница по пространству
	d2Sx   byte //7:d2Sx  вторая производная по пространству
	dSxdSt byte //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataInt16 - ячейка с по
 */
type DataInt16 struct {
	data   int16 // слово с данными
	dSt    int16 // текущая разница по времени
	dSt2   int16 //3:dSt2 предыдущая разница по времени
	d2St   int16 //4:d2St вторая производная по времени
	dSx    int16 //5:dSx   текущая разница по пространству
	dSx2   int16 //6:dSx2  предыдущая разница по пространству
	d2Sx   int16 //7:d2Sx  вторая производная по пространству
	dSxdSt int16 //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataInt32 - ячейка с по
 */
type DataInt32 struct {
	data   int32 // слово с данными
	dSt    int32 // текущая разница по времени
	dSt2   int32 //3:dSt2 предыдущая разница по времени
	d2St   int32 //4:d2St вторая производная по времени
	dSx    int32 //5:dSx   текущая разница по пространству
	dSx2   int32 //6:dSx2  предыдущая разница по пространству
	d2Sx   int32 //7:d2Sx  вторая производная по пространству
	dSxdSt int32 //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataInt64 - ячейка с по
 */
type DataInt64 struct {
	data   int64 // слово с данными
	dSt    int64 // текущая разница по времени
	dSt2   int64 //3:dSt2 предыдущая разница по времени
	d2St   int64 //4:d2St вторая производная по времени
	dSx    int64 //5:dSx   текущая разница по пространству
	dSx2   int64 //6:dSx2  предыдущая разница по пространству
	d2Sx   int64 //7:d2Sx  вторая производная по пространству
	dSxdSt int64 //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataUInt16 - ячейка с по
 */
type DataUInt16 struct {
	data   uint16 // слово с данными
	dSt    uint16 // текущая разница по времени
	dSt2   uint16 //3:dSt2 предыдущая разница по времени
	d2St   uint16 //4:d2St вторая производная по времени
	dSx    uint16 //5:dSx   текущая разница по пространству
	dSx2   uint16 //6:dSx2  предыдущая разница по пространству
	d2Sx   uint16 //7:d2Sx  вторая производная по пространству
	dSxdSt uint16 //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataUInt32 - ячейка с по
 */
type DataUInt32 struct {
	data   uint32 // слово с данными
	dSt    uint32 // текущая разница по времени
	dSt2   uint32 //3:dSt2 предыдущая разница по времени
	d2St   uint32 //4:d2St вторая производная по времени
	dSx    uint32 //5:dSx   текущая разница по пространству
	dSx2   uint32 //6:dSx2  предыдущая разница по пространству
	d2Sx   uint32 //7:d2Sx  вторая производная по пространству
	dSxdSt uint32 //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataUInt64 - ячейка с по
 */
type DataUInt64 struct {
	data   uint64 // слово с данными
	dSt    uint64 // текущая разница по времени
	dSt2   uint64 //3:dSt2 предыдущая разница по времени
	d2St   uint64 //4:d2St вторая производная по времени
	dSx    uint64 //5:dSx   текущая разница по пространству
	dSx2   uint64 //6:dSx2  предыдущая разница по пространству
	d2Sx   uint64 //7:d2Sx  вторая производная по пространству
	dSxdSt uint64 //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataFloat32 - ячейка с по
 */
type DataFloat32 struct {
	data   float32 // слово с данными
	dSt    float32 // текущая разница по времени
	dSt2   float32 //3:dSt2 предыдущая разница по времени
	d2St   float32 //4:d2St вторая производная по времени
	dSx    float32 //5:dSx   текущая разница по пространству
	dSx2   float32 //6:dSx2  предыдущая разница по пространству
	d2Sx   float32 //7:d2Sx  вторая производная по пространству
	dSxdSt float32 //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataFloat64 - ячейка с по
 */
type DataFloat64 struct {
	data   float64 // слово с данными
	dSt    float64 // текущая разница по времени
	dSt2   float64 //3:dSt2 предыдущая разница по времени
	d2St   float64 //4:d2St вторая производная по времени
	dSx    float64 //5:dSx   текущая разница по пространству
	dSx2   float64 //6:dSx2  предыдущая разница по пространству
	d2Sx   float64 //7:d2Sx  вторая производная по пространству
	dSxdSt float64 //(изменение сигнала по пространству отнесенное к изменению сигнала по времени, скорость изменения)
}

/*DataBit - ячейка с данными из битов (если существенны именно биты)
Данные, кстати можно варьировать и комбинировать для одних и тех же входящих данных. Все это должно быть просто описано в рецепторном геноме

*/
type DataBit struct {
	data byte //данные
	mask byte //маска битов
}

//Receptor - минимальная единица, передающая вещества от входных данных
/*
Является, по сути переводчиком с языка цифр (информации) на язык веществ

Данные складываются в специальный файл и сразу обрабатываются. Вычисляются их производные по времени и пространству, и вторые производные
и даже скорость.
На каждый из этих параметров (чистых и вычисленных) необходимо поставить по два рецептора - положительный и отрицательный.
Положительный выдает вещество (ацетилхолин?) по своим аксонам пропорцианально величине параметра.
Отрицательный выдает вещество обратно пропорцианально величине параметра.
Например, если данные состоят из байтов:
при значении 200 в данных, рецептор положительный выдаст 200 ацетилхолина, а отрицательный выдаст 255-200=55
при значении 0 в данных, рецептор положительный выдаст 0 ацетилхолина, а отрицательный выдаст 255-0=255

Еще можно разработать рецептор среднего значения, который тем больше плюет, чем ближе к среднему значению.
Да и вообще какой угодно, если угодно, надо экспериментировать))
Таким образом, вещества сигнализируют не только большие данные, а вообще всякие.

У рецепторов аксоны направлены в свой файл синапсов, свойственный данному типу входного сигнала.
Фактически, первичная зрительная кора, например, будет распологаться (и клеточно и синаптически) отдельно от мозга, являясь периферическим входом
*/
type Receptor struct {
}

//Effector - минимальная единица, передающая вещества в выходные данные
/*
Является, по сути переводчиком с языка веществ на язык цифр (информации)

Эффекторы могут менять значения в выходных файлах следующим образом:
у эффекторов вместо аксонов выходная величина гестеризует включение и выключение конкретного бита в выходном файле.
Ну или байта?
*/
type Effector struct {
}
