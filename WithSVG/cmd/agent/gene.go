package agent

/*GenNeuron - структура одного гена нейронов из файла генома

 */
//388 байт
type GenNeuron struct {
	Typen NeuronTypeEnum //тип клетки: 10 - стволовые...
	Serv1 byte           //зарезервировано (byte выравнивание)
	Coren CoreEnum       /*номер синаптического поля (ядра или входа или выхода), в синапсах которого находятся аксоны
	0xffff - аксоны в этом же поле синапсов, текущем, где описан нейрон
	x - аксоны в ядре х, это сигнал ядру, что оно должно АКСОНЫ нейрона обрабатывать в другом файле синапсов
	если x совпадет с номером этого ядра - будет тоже самое, что 0xffff
	у ядра есть ссылка на весь организм, и оно может попросить у организма нужный синапс из любого поля синапсов

	0xfffe - аксоны расположены в общем синаптическом файле всех входов мозга (для реализации связей между разными входами)
	Поскольку нейроны могут быть расположены не только в мозге, но и в входных устройствах, у всех входных устройств может быть свое
	синаптическое поле, и обязательно есть общее синаптическое поле (в простых агентах это может не использоваться, но возможность такая есть)

	Итого у нас 0xffff зарезервирован для текущего ядра (или текущего входа),
		а 0xfffe зарезервирован для общего поля всех входов
	*/

	MaxX uint32 /*(количество синапсов по Х) максимальная ширина файла синапсов того поля синапсов, где лежит сома, т.е. этого текущего ядра
	  Эта величина используется для вычисления номера синапса в одномерном массиве синапсов, исходя из
	  координат:  N = x + y * maxX
	  При генерации клеток, вычисляют сначала их координаты (и координаты отростков), а потом переводятся
	  в индекс одномерного массива
	  Массив одномерный, потому что Го плохо работает с многомерными, а там надо отображения с файла иметь
	*/

	MaxXOtherCore uint32 //если аксоны находятся в другом файле синапсов, отличных от текущего, т.е. core!=COREMY, то нужно знать ширину того поля

	Layers   uint16 //количество слоев таких клеток
	Serv2 uint16

	Laywidth uint32 //количество клеток в одном слое (умножить на layers и будет клеток всего)

	Soma1stX        uint32 //x-координата сомы 1ой клетки в 1ом слое
	Soma1stY        uint32 //y-координата сомы 1ой клетки в 1ом слое
	SomaNextShiftX  uint16 //сдвиг каждой следующей сомы по координате X
	SomaNextShiftY  uint16 //сдвиг каждой следующей сомы по координате Y
	SomaLayerShiftX uint16 //сдвиг каждого слоя относительно предыдущего по Х
	SomaLayerShiftY uint16 //сдвиг каждого слоя относительно предыдущего по Y

	Dend1stX        uint32 //x-координата 1-го дендрита 1ой клетки в 1ом слое
	Dend1stY        uint32 //y-координата 1-го дендрита 1ой клетки в 1ом слое
	DendShiftX      uint16 //сдвиг каждого следующего дендрита одной и той же клетки по координате X
	DendShiftY      uint16 //сдвиг каждого следующего дендрита одной и той же клетки по координате Y (тогда дендриты одной клетки будут по диагонали распологаться)
	DendNextShiftX  uint16 //сдвиг 1-го дендрита следующей клетки по координате X относительно 1-го дендрита предыдущей клетки
	DendNextShiftY  uint16 //сдвиг 1-го дендрита следующей клетки по координате Y относительно 1-го дендрита предыдущей клетки
	DendLayerShiftX uint16 //сдвиг следующего слоя по Х
	DendLayerShiftY uint16 //сдвиг следующего слоя по Y
	/*про дендриты кажется запутанным, но:
	         Y=201
	           | 	   одними символами обозначены дендриты одной клетки
	          \|/       на рисунке ось Х направлена вправо, ось У вниз
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	X=354--->| x |   |   |   | + |   |   |   | 0 |   |   |   | # |   |   |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         |   | x |   |   |   | + |   |   |   | 0 |   |   |   | # |   |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         |   |   | x |   |   |   | + |   |   |   | 0 |   |   |   | # |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         | " |   |   | x | @ |   |   | + | $ |   |   | 0 | % |   |   | # |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         |   | " |   |   | x | @ |   |   | + | $ |   |   | 0 | % |   |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	         |   |   | " |   |   | x | @ |   |   | + | $ |   |   | 0 | % |   |
	         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
			 |   |   |   | " |   |   | x | @ |   |   | + | $ |   |   | 0 | % |
			 +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

	dend1stX        =  354
	dend1stY        =  201
	dendShiftX      =  1
	dendShiftY 	    =  1
	dendNextShiftX  =  4
	dendNextShiftY  =  0
	dendLayerShiftX =  0
	dendLayerShiftY =  3
	*/

	Ax1stX        uint32 //x-координата 1-го аксона 1ой клетки в 1ом слое
	Ax1stY        uint32 //y-координата 1-го аксона 1ой клетки в 1ом слое
	AxShiftX      uint16 //сдвиг каждого следующего аксона одной и той же клетки по координате X
	AxShiftY      uint16 //сдвиг каждого следующего аксона одной и той же клетки по координате Y (тогда аксоны одной клетки будут по диагонали распологаться)
	AxNextShiftX  uint16 //сдвиг 1-го аксона следующей клетки по координате X относительно 1-го аксона предыдущей клетки
	AxNextShiftY  uint16 //сдвиг 1-го аксона следующей клетки по координате Y относительно 1-го аксона предыдущей клетки
	AxLayerShiftX uint16 //сдвиг следующего слоя по Х
	AxLayerShiftY uint16 //сдвиг следующего слоя по Y

	Neur Neuron //типичный нейрон для такого типа клеток (используется для генерации клеток)

	Serv3 [4]uint32 //зарезервировано 16 байт
}

/*GenData - структура гена для файлов с данными
При первом старте агента, ВМ считывает ген из файла и создает файл входных данных по генетическому описанию.
Ген также содержит некоторые описания работы с этими данными, специфичными для разных типов данных. Поэтому он нужен не только при
генерации файла с данными, но и при работе с ними
*/
//28 байт
type GenData struct {
	Datatype DataTypeEnum //тип данных из data.go  1-DataByte...
	Dataneed byte         /*нуждаются ли данные в дополнительной мат-оброботке. 0 - они полностью готовы к использованию
	(тот, кто ложил или присылал данные позаботился о предварительных вычислениях)*/

	Runifchange byte //надо ли запускать рецепторы сразу при приходе новых данных, или пользоваться только частотной характеристикой

	Fps      uint16 //средняя частота обновления данных, милисек. 0-данные нужно обрабатывать как можно чаще
	Httpchan uint16 /*Канал http-данных. уникальное число для этого входа
	0 - без канала (означает, что данные записывает прямо в файл некий сторонний процесс)
	1,2,3... данные получает агент на свой http-сервер через апи
	в настоящий момет используется только возможность http, т.к.
	для  непоследственной записи сторонним процессом необходимо разбираться более глубоко в MemoryMap
	*/
	Len uint32 //длина данных (количество ячеек с данными, а не размер файла!!)

	Serv1  [4]uint32 //зарезервировано 16 байт на будущее
}

/*GenReceptor - ген рецепторов
Этот ген может сгенерировать рецепторы любого типа. Просто некоторые названия полей будут для разных типов рецепторов иметь
разный смысл.
*/
//352 байта
type GenReceptor struct {
	Typer ReceptorTypeEnum //тип рецептора. четные - для положительных, нечетные - для отрицательных
	Coren CoreEnum //в какое синаптическое поле направлены аксоны этих клеток, 0xffff - в это же, в поле входа

	/*
		За то, что обозначают следующие переменные несет ответственность логика работы, обозначаемая типом рецептора Typer
		Генератор рецепторов, глядя в ген, заполнит поля в рецепторах Ndata NdataW NdataWB простым способом:

		cur:=0
		for i:=Ndata; i<= Maxi; i=i+Iteri{
			for j:=NdataW; j<= Maxj; j=j+Iterj{
				for k:=NdataWB; k<=Maxk; k=k+Iterk {
					Receptor[cur].Ndata=i
					Receptor[cur].NdataW=j
					Receptor[cur].NdataWB=k
					cur++
				}
			}
		}

	*/
	Ndata   uint32 //стартовое значение цикла по i - чаще всего используется для номера ячейки данных, т.к. самих ячеек больше всего обычно

	NdataW  byte   //стартовое значение цикла по j - чаще всего для номера байта из этой ячейки
	NdataWB byte   //стартовое значение цикла по k - ну если еще и биты адрессовать надо или хз чего еще))

	Typemedi NeuronTypeEnum //тип выплевываемого медиатора (обычно ацетилхолин)
	Serv1    byte           //зарезервировано (выравнивает до 4 byte)

	//максимумы (включительно) итерации
	Maxi uint32
	//Maxj byte - перенесено для выравнивания
	//Maxk byte

	//итераторы
	Iteri uint32
	Iterj byte
	Iterk byte

	Maxj byte //сюда перенесено)
	Maxk byte

	/*
				Например, если нужно сделать 10 рецепторов с Ndata от 0 до 9, NdataW=2, NdataWB=0:
				Ndata, NdataW, NdataWB = 0, 2, 0
				Maxi, Maxj, Maxk = 9, 2, 0
				Iteri, Iterj, Iterk = 1,1,1

				Если нужно 80 рецпторов с Ndata от 0 до 9, NdataW=1, NdataWB=0..7
				Ndata, NdataW, NdataWB = 0, 1, 0
				Maxi, Maxj, Maxk = 9, 1, 7
				Iteri, Iterj, Iterk = 1,1,1

		Если мало этих возможностей - можно создать еще сколько угодно генов на тот же тип, с другими параметрами

		Количество рецепторов задается автоматически этими циклами
	*/

	/*
		Далее, для каждого рецептора формируются аксоны
		x:=Ax1stX
		y:= Ax1stY

		for c:=0; c<num; c++ {
			fmt.Printf("%v:",c)
			xs:=x
			ys:=y
			for i:=0;i<32;i++{
				fmt.Printf("%v,%v | ", x, y)
				x=x+AxShiftX
				y=y+AxShiftY

			}
			fmt.Println()
			x=xs+AxNextShiftX
			y=ys+AxNextShiftY
		}

		Если нужен еще слой рецепторов на эти же данные - просто делаем еще один ген
	*/

	MaxX uint32 //ширина синаптического поля, куда направлены аксоны рецептора

	Ax1stX       uint32 //x-координата 1-го аксона 1ой рецептора в 1ом слое
	Ax1stY       uint32 //y-координата 1-го аксона 1ой рецептора в 1ом слое
	AxShiftX     uint16 //сдвиг каждого следующего аксона одной и той же рецептора по координате X
	AxShiftY     uint16 //сдвиг каждого следующего аксона одной и той же рецептора по координате Y (тогда аксоны одной рецептора будут по диагонали распологаться)
	AxNextShiftX uint16 //сдвиг 1-го аксона следующей рецептора по координате X относительно 1-го аксона предыдущей рецептора
	AxNextShiftY uint16 //сдвиг 1-го аксона следующей рецептора по координате Y относительно 1-го аксона предыдущей рецептора

	Serv2		uint32//потому что Receptor выровнен по 8 байт
	Recep        Receptor //типичный рецептор для такого типа рецепторов (используется для генерации)
	Serv3  [4]uint32   //зарезервировано
}

/*
Механизм работы выходов
-----------------------

Выходы состоят из преффекторов (Preffector) и эффекторов (Effector)
Преффекторы - это что-то похожее на нейроны, только они не приспосабливаются, не имеют веществ внутри себя, имеют большое дендритное дерево,
"слушающее" в принципе любое указанное синаптическое поле. У преффекторов есть только один выход - некая величина байта, которую они хранят
внутри себя. Преффекторы могут быть разных типов (например, положительные и отрицательные). Положительные увеличивают свой выход (байт)  в ответ
на присутствие неких веществ, а отрицательные увелчивают свой выход в ответ на отсутствие.
Дендриты преффекторов все метаботробные.
У каждого преффектора есть число-указатель (по сути номер) эффектора.
Эффектор считывает со своих преффекторов выходы и принимает решение о неком среднем (или целом значении), которое и записывается в выходной файл.
Файл выходной является по сути выходом из организма. Его данные попадают на исполнительные устройства через драйвера, или организм может
анализировать содержимое некоторых из них в своих целях.

*/

/*GenPreffector - рецепторы "наоборот", переводят вещества в данные, которые потом анализируют эффекторы и выводят в выходной файл

 */
//344
type GenPreffector struct {
	Typep PreffectorTypeEnum   //тип преффектора
	Coren CoreEnum //синаптическое поле, где лежат дендриты преффектора (может быть свое поле)

	Ndata   uint32 //стартовое значение цикла по i - чаще всего используется для номера ячейки данных, т.к. самих ячеек больше всего обычно

	NdataW  byte   //стартовое значение цикла по j - чаще всего для номера байта из этой ячейки
	NdataWB byte   //стартовое значение цикла по k - ну если еще и биты адрессовать надо или хз чего еще))
	Serv1 uint16

	//максимумы (включительно) итерации
	Maxi uint32
	//Maxj byte - перенесено внз для выравнваня
	//Maxk byte

	//итераторы
	Iteri uint32

	Iterj byte
	Iterk byte
	Maxj byte
	Maxk byte

	MaxX uint32 //ширина файла синапсов, где лежат дендриты

	Dend1stX       uint32 //x-координата 1-го дендрита 1ой клетки в 1ом слое
	Dend1stY       uint32 //y-координата 1-го дендрита 1ой клетки в 1ом слое
	DendShiftX     uint16 //сдвиг каждого следующего дендрита одной и той же клетки по координате X
	DendShiftY     uint16 //сдвиг каждого следующего дендрита одной и той же клетки по координате Y (тогда дендриты одной клетки будут по диагонали распологаться)
	DendNextShiftX uint16 //сдвиг 1-го дендрита следующей клетки по координате X относительно 1-го дендрита предыдущей клетки
	DendNextShiftY uint16 //сдвиг 1-го дендрита следующей клетки по координате Y относительно 1-го дендрита предыдущей клетки

	Serv2 uint32  //потому что Preffector выровнян по 8 байт
	Prefec Preffector //пример такого эффектора

	Serv3 [4]uint32 //зарезервировано
}

/*GenDataOut - ген файла выходных данных
 */
//28 байт
type GenDataOut struct {
	Datatype DataTypeEnum //тип выходных данных из data.go
	Serv1 uint16
	Fps      uint16 //средняя частота обновления данных, милисек. 0-данные нужно складывать как можно чаще
	Httpchan uint16 /*Канал http-данных. уникальное число для этого выхода
	0 - без канала (означает, что данные забирает прямо из файла некий сторонний процесс)
	1,2,3... данные отсылает агент на http-сервер через апи
	*/
	Len          uint32 //длина данных (количество ячеек с данными, а не размер файла!!)
	Serv2 [4]uint32 //зарезервировано
}
