package main

import (
	"fmt"
	"github.com/guptarohit/asciigraph"
	"math/rand"
)
type Chemical struct {
	/*
		НЕЛЬЗЯ МЕНЯТЬ ПОРЯДОК СЛЕДОВАНИЯ ПОЛЕЙ!!! И ДОБАВЛЯТЬ, КАК-ТО ИЗМЕНЯТЬ ЭТО!!! ИСПОЛЬЗУЕТСЯ unsafe!!! для маппинга структуры на часть файла
	*/
	GLUC  uint16 //[0]Глюкоза (энергетически важная молекула, участвует во многих процессах клетки)
	O2    uint16 //[2]окислитель глюкозы, без него процессы генерации веществ из глюкозы не идут
	WASTE uint16 //[4]всякая кака, которую организм выводит
	OMEGA uint16 //[6]жирная кислота, использующаяся для синтеза мембран всех клеток. Из нее также в некоторых клетках синтезируется анандамид, который очень быстро разлагается на этаноламин и арахидоновую кислоту. Из этаноламина получается холин.
	K     byte   //[8]ион калия, выводит каку, создает ток разряда, перекачивается Na-K-ATPasa
	Na    byte   //[9]ион натрия, вводит нямку, создает ток разряда, перекачивается Na-K-ATPasa
	CO    byte   //[10](рассеивается при высвобождении по всем близлешащим клеткам), связан с окислением глюкозы, выделяется на дендритах в ответ на открытие на них ионных каналов, в основном в дофаминовых и серотониновых
	NO    byte   //[11](рассеивается при высвобождении по всем близлешащим клеткам), связан с глутаматом
	ACh   byte   //[12]Ацетилхолин (в основном в перефирических файлах входных и выходных устройств), синтезируется из глюкозы и холина
	CHOL  byte   //[13]Холин. Синтезируется из анандамида или OMEGA. Нужен для работы ацетилзолиновых синапсов
	AA    byte   //[14]анандамид, медиатор, действующий на аксон ГАМК возбуждающе, а на аксон глютамата торможающе)
	GLU   byte   //[15]Глютамат (главный медиатор, в информационной модели он возбуждающий, но мы не будем болше говорить о возбуждении и торможении, а только о различных состояниях жизни клетки), синтезируется из глутамина снаружи клетки или из аспартата внутри
	GABA  byte   //[16]ГАМК, синтезируется из глютамата, быстро распадается, переходя в глюкозу
	GLN   byte   //[17]ГЛУТАМИН - синтезируется из аспартата снаружи, выводится в некотором количестве, участвует в цикле Глутамат-захвата. Глутаматные нейроны синтезируют глутамат только из глутамина. Глутамат в синапсе превращается в глутамин.
	NE    byte   //[18]Норадреналин, синтезируется из дофамина. Всасывается обратно и частично выводится.
	DOP   byte   //[19]Дофамин, синтезируется из тирозина. Всасывается обратно в аксонах и частично выводится. Из него синтезируется норадреналин.
	SER   byte   //[20]Серотонин. Синтезируется из триптофана.  Всасывается обратно и частично выводится.
	TYR   byte   //[21]Тирозин - для синтеза дофамина
	TRP   byte   //[22]Триптофан - для синтеза серотонина.
	ASP   byte   //[23]Аспартат - для синтеза глутамата
}

type Dendrite struct {

	Typed byte
	Ca byte   //количество кальция в этом шипике
	State byte
	Charge int8
	N  uint32 //номер синапса в файле синапсов. Координаты его вычисляются по номеру:  y = N / maxX   x = N % maxX

}

type N struct{
	K byte
	Na byte
	State byte
	d Dendrite
	c Chemical
}

const (
	NACHANOPEN int = -65		//уровень заряда открытия Натриевого канала
	NACHANCLOSE int = 15		//уровень заряда закрытия Натриевого канала
	KCHANOPEN int = 20			//уровень заряда открытия Калиевого канала
	KCHANCLOSE int = -55		//уровень заряда закрытия Калиевого канала
	CHARGENORM int = -75		//нормальный (базовый) уровень заряда

	NAVALCHANREOPEN byte = 20 	//уровень натрия в клетке, ниже которого возможна повторная реполяризация в том же цикле
	KVALCHANREOPEN byte = 30    //уровень калия в клетке, выше которого возможна повторная реполяризация в том же цикле

	NAORG byte =240   			//уровень натрия в межклеточной жидкости
	KORG byte =10				//уровень калия в межклеточной жидкости

	MINSOMACHARGE=-10           //минимальный заряд сомы, ниже которого кальциевые каналы сомы не открываются, и кальций не попадает из сомы в дендриты
	MAXCA byte = 30				//максимальное количество кальция, выше которого ставится под вопрос депрессия
	MINCA byte = 3				//минимальное количество кальция, ниже которого ставится под вопрос потенциация
	MAXCASOMA byte = 100 		//количество кальция, попадающего в дендрит из сомы, во время ПД сомы
	MAXACH byte = 30			//максимальное количество АЦХ, выше которого ставится под вопрос депрессия или потенциация
	MINACH byte = 5				//минимальное количество АЦХ, выше которого алгоритм обучения продолжает работу
	MINACHREACT byte = 10		//минимальное количество АЦХ, способное открыть хотя бы один канал кальция

)

func NAKATFasa(n *N){
	if CalcCharge(n)<CHARGENORM-20{
		return
	}
	if n.Na>5 {
		n.Na-=3
	}
	if n.K<250{
		n.K+=2
	}
}

func CalcCharge(n *N) int{
	ret:=int((float32(n.Na) - float32(NAORG) + float32(n.K) - float32(KORG)-130)/1.7)
	return ret
}

func DendrCharge(n *N) int{
	//пробегаемся по дендритам и вычисляем их сумарное зарядное влияние на сому (среднее арифм или геом)
	chdend:=int(n.d.Charge)
	if chdend>40 {//ограничение по максимуму влияния дендритов
		return 40
	}
	if chdend < -40{
		return -40
	}
	return chdend
}

func Gradient(n *N){
	if n.Na>NAORG{
		n.Na-=1
	}
	if n.Na<NAORG{
		n.Na+=1
	}
	if n.K>KORG{
		n.K-=1
	}
	if n.K<KORG{
		n.K+=1
	}
}
func NaOpened(n *N){
	if n.Na < 150{
		n.Na+=90
	}else if n.Na < 210{
		n.Na+=40
	}else if n.Na < 240{
		n.Na+=20
	}else if n.Na < 250{
		n.Na+=3
	}
}
func KOpened(n *N){
	if n.K>150{
		n.K-=40
	}else if n.K>75{
		n.K-=25
	}else if n.K>20{
		n.K-=8
	}else if n.K>5{
		n.K-=3
	}
}

func DoDendr(n *N){
	//ацх-эргический дендрит

	if CalcCharge(n)>MINSOMACHARGE{//если заряд сомы больше MINSOMACHARGE, значит она делает ПД, и ее кальциевые каналы открыты
		n.d.Ca=MAXCASOMA //и значит кальций входит в дендрит через сому
	}else if n.d.Ca>1 {//кальций выходит из каналов
		n.d.Ca-=1
		if n.d.Ca>MAXCA*2{
			n.d.Ca=byte((int16(n.d.Ca)*7 + int16(MINCA))/8)
		}
	}
	//сила рецепторов
	Power:=0xf0 & n.d.Typed

	//чем сильней рецептор, тем быстрее выходит кальций
	if n.d.Ca> Power/0x10{
		n.d.Ca-=Power/0x10
	}else {
		n.d.Ca=1
	}

	ACH:=n.c.ACh

	//если мы в долгосрочной депрессии, мы пропускаем обработку синапса совсем, аксону это не понравится и он отключится (или нет - это нне наши проблемы)
	if n.d.State<200 && ACH>0{ //мы не в долгосрочной депресии и есть ли медиатор в синапсе?
		//эстераза разрушает ацх, а если мы в депрессии - то не разрушаем
		n.c.CHOL=ACH //+n.c.CHOL //здесь в реале надо прибавить существующий холин
		n.c.ACh=0

		//достаточно ли медиатора, чтобы открыть ионные каналы (зависит также от силы дендрита)
		if ACH*(Power/0x10) >= MINACHREACT  {
			//количество заряда (относительное). поскольку ацх - возбужд, заряд от нуля до +120
			ch := int(float32(Power)/10* float32(ACH) / (float32(n.d.Ca) + 4))
			//ограничение заряда (для тормозных проверка отрицательная должна быть)
			if ch > 120 {
				n.d.Charge = 120
			} else {
				n.d.Charge = int8(ch)
			}

		}else{
			n.d.Charge = 0
		}

	}else{//если медиатора нет или мы в ДД - наши каналы закрыты, заряд КП 0
		n.d.Charge = 0
	}

	//обучение проходит только если медиатор присутствовал в щели в минимальном количестве
	//иначе получим такую штуку, что мы приспосабливаемся не к работе пресинаптического нейрона
	if ACH>=MINACH{
		//если в ДД, уменьшаем ожидание
		if n.d.State>200 {
			n.d.State--
		}else if n.d.State>102 && n.d.State<150{//если в ДП, тоже уменьшаем
			n.d.State--
		} else{
			//состояние обучения
			switch n.d.State{
			case 1: //обычная работа
				if n.d.Ca>MAXCA && ACH>MAXACH{
					//здесь краткосрочная депрессия ставится на проверку
					n.d.State=10
				}else if n.d.Ca<MINCA && ACH>MAXACH{
					//краткосрочная потенциация ставится на проверку
					n.d.State=100
				}
			case 9://конец краткосрочной депрессии
				if n.d.Ca>MAXCA && ACH>MAXACH{
					//здесь краткосрочная депрессия продолжается
					n.d.State+=1
				}else {
					n.d.State=1//нормальный режим
				}
			case 10, 11, 12:
				if n.d.Ca>MAXCA && ACH>MAXACH{
					//здесь краткосрочная депрессия продолжается
					n.d.State+=1
				}else {
					n.d.State-=1
				}
			case 13:
				if n.d.Ca>MAXCA && ACH>MAXACH{
					//таки депрессия
					if Power == 0x10 {//уже некуда депрессировать, переходим в долговременную депрессию
						n.d.State=255
						break
					}else {
						Power=Power-0x10
						n.d.State-=1 //дадим шанс не выключить еще рецепторов на следующем шаге
					}
					n.d.Typed = Power + (n.d.Typed&0x0f)
				}else {
					n.d.State-=1
				}
			case 100:
				if n.d.Ca<MINCA && ACH>MAXACH{
					//краткосрочная потенциация продолжает проверку
					n.d.State=101
				} else{
					//показалось
					n.d.State=1
				}
			case 101:
				if n.d.Ca<MINCA && ACH>MAXACH{
					//таки да, нейрон пресинаптический плюет когда надо, увеличиваем кол-во рецепторов
					if Power<0xf0{
						Power+=0x10
					} else {
						//итак максимально сильный дендрит... TODO!
					}
					n.d.Typed = Power + (n.d.Typed&0x0f)
					n.d.State=110 //это же долговременная потенциация? доверяем пресинаптическому нейрону некоторое время
				} else{
					//показалось
					n.d.State=1
				}
			case 102:
				n.d.State=1 //ДП (долговременная потенциация) окончена, обычная работа
			case 200: //долговременная депрессия (ДД) конец, но мы идем в краткосрочную
				n.d.State=9

			default:
				if n.d.Ca>MAXCA && ACH>MAXACH{
					//здесь краткосрочная депрессия ставится на проверку
					n.d.State=10
				}else if n.d.Ca<MINCA && ACH>MAXACH{
					//краткосрочная потенциация ставится на проверку
					n.d.State=100
				}
				n.d.State=1
			}
		}
		//поскольку в синапсе есть медиатор, он открыл каналы кальция, и кальций входит в дендрит из синапса
		//и в принципе, может немного выйти, если нейромедиатора мало, а кальция много
		n.d.Ca=byte((int(n.d.Ca)*2+int(ACH))/3)
	}
}

func Step(n *N){

	DoDendr(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	NAKATFasa(n)
	//среднее по всем дендритам должно быть
	charge:=CalcCharge(n)+DendrCharge(n)

	switch n.State{
	case 1://норм
		if charge<CHARGENORM{ //глубокая реполяризация, каналы открыты для выравнивания
			Gradient(n)

		}
		if charge>NACHANOPEN{
			n.State=10
			NaOpened(n)
			charge=CalcCharge(n)//+DendrCharge(n)
			if charge>=NACHANCLOSE{
				n.State=20
			}
		}
	case 10://начало деполяризации

		if charge>=NACHANOPEN && charge<=NACHANCLOSE{
			NaOpened(n)
			charge=CalcCharge(n)//+DendrCharge(n)
		}
		if charge>=KCHANOPEN {
			KOpened(n)
			charge=CalcCharge(n)//+DendrCharge(n)

			if charge> NACHANOPEN && n.Na<NAVALCHANREOPEN && n.K>KVALCHANREOPEN{
				n.State=1
			}

		}
		if charge>=NACHANCLOSE{
			n.State=20
		}

	case 20://только калиевый ток

		KOpened(n)
		charge:=CalcCharge(n)//+DendrCharge(n)
		if charge<KCHANCLOSE {
			n.State=1
		}

		if charge> NACHANOPEN && n.Na<NAVALCHANREOPEN && n.K>KVALCHANREOPEN{
			n.State=10
		}

	default:
		n.State=1
	}
	if rand.Intn(100)>10{
		Gradient(n)
	}

}

func main() {
	n:=N{248,3, 1,Dendrite{0x14,5,1,0,0},Chemical{ACh:0, CHOL:0}}

	dataCH := []float64{}
	dataNa := []float64{}
	dataK := []float64{}
	dataPIC:=[]float64{}
	dataDCa:=[]float64{}
	dataDCH:=[]float64{}
	for i:=0;i<200;i++{
		if (i>68&& i<70) ||(i>72&& i<74) || (i>76&& i<78) ||
			(i>80&& i<82) || (i>84&& i<86) || (i>88 && i<90) || (i>92 && i<94)||
			(i==95) ||(i==97) || (i==99) ||(i==101) ||(i==103) || (i==105){
		/*
		(i>68&& i<70) ||(i>72&& i<74) || (i>76&& i<78) ||
				(i>80&& i<82) || (i>84&& i<86) || (i>88 && i<90) || (i>92 && i<94)||
				(i==95) ||(i==97) || (i==99) ||(i==101) ||(i==103) || (i==105){

			(i>68&& i<70) ||(i>72&& i<74) || (i>76&& i<78) ||
			(i>80&& i<82) || (i>84&& i<86) || (i>88 && i<90) || (i>92 && i<94){

			i==5 || i==75  || i==150 || i==250 || i==350 {
			*/

			n.c.ACh =50
			dataPIC=append(dataPIC, float64(n.c.ACh))
			Step(&n)

		/*} else if(i>150&& i<153) {
			n.c.ACh = 80
			Step(&n)
			dataPIC=append(dataPIC, 80)*/
		} else{
			//n.c.ACh =0
			Step(&n)
			dataPIC=append(dataPIC, float64(n.c.ACh))
		}
		dataCH=append(dataCH, float64(CalcCharge(&n)))
		dataNa=append(dataNa, float64(n.Na))
		dataK=append(dataK, float64(n.K))
		dataDCa=append(dataDCa, float64(n.d.Ca))
		dataDCH=append(dataDCH, float64(n.d.Charge))
	}
	graphCH := asciigraph.Plot(dataCH, asciigraph.Height(15),asciigraph.Width(200), asciigraph.Caption("Заряд клетки"))
	graphDCH := asciigraph.Plot(dataDCH, asciigraph.Height(15),asciigraph.Width(200), asciigraph.Caption("Заряд дендрита"))
	graphDCa := asciigraph.Plot(dataDCa, asciigraph.Height(15),asciigraph.Width(200), asciigraph.Caption("Кальций в дендрите"))
	graphNa := asciigraph.Plot(dataNa, asciigraph.Height(5),asciigraph.Width(200), asciigraph.Caption("Натрий"))
	graphK := asciigraph.Plot(dataK, asciigraph.Height(5),asciigraph.Width(200), asciigraph.Caption("Калий"))
	graphPIC := asciigraph.Plot(dataPIC, asciigraph.Height(5),asciigraph.Width(200), asciigraph.Caption("Раздражение дендрита"))

	fmt.Println("--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println(graphCH)
	fmt.Println("--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println(graphDCH)
	fmt.Println("--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println(graphDCa)
	fmt.Println("--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println(graphNa)
	fmt.Println("--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println(graphK)
	fmt.Println("--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println(graphPIC)
	fmt.Println("--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------")
}
